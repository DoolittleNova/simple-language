package edu.appstate.cs.analysis.parser;

import edu.appstate.cs.analysis.ast.*;
import java.math.BigInteger;
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "lang.grammar".
 */
public class LanguageParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short IDENTIFIER = 1;
		static public final short INTEGER = 2;
		static public final short NOT = 3;
		static public final short MULT = 4;
		static public final short DIV = 5;
		static public final short PLUS = 6;
		static public final short EQUAL = 7;
		static public final short NOTEQL = 8;
		static public final short IF = 9;
		static public final short FOR = 10;
		static public final short WHILE = 11;
		static public final short VAR = 12;
		static public final short RETURN = 13;
		static public final short OR = 14;
		static public final short AND = 15;
		static public final short LCURLY = 16;
		static public final short RCURLY = 17;
		static public final short SEMI = 18;
		static public final short THEN = 19;
		static public final short ELSE = 20;
		static public final short ELSEIF = 21;
		static public final short COMMA = 22;
		static public final short LBRACKET = 23;
		static public final short RBRACKET = 24;
		static public final short LPAREN = 25;
		static public final short RPAREN = 26;
		static public final short STRING = 27;
		static public final short TRUE = 28;
		static public final short FALSE = 29;
		static public final short SUB = 30;
		static public final short IN = 31;
		static public final short ASSIGN = 32;
	}
	static public class AltGoals {
		static public final short placeholder = 33;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9o5bKjCKq4KXlyMh42b52W85H7ROa4KdyMtuWFVBn9ZubPTk3Gc9YvCSAMkNBWmxbseCJ7" +
		"HI69YGgAeQAA4nAN6615H54LyFyV$pfnBfxKNB$dc$FVCEVCuSwS0FZ$2Y261LcmHjHGpC1" +
		"kBC3#jb48bwX115Mej5KKD9Y0FvLhDbFmKIX3IKUcHqZacPXqswPmvEMCoPzZCs8LQvQi$Q" +
		"F6CCoClHy1x7z8Jr#r45EMStVGM86YDkasyXJapKl1pnyMOXAZgDv7gj$J7hHbDM#RPaq8J" +
		"nt7rt37jUbRIay8QtMwm8dTGbw82ar6DAPYAQPYEUYJHW4RCGZFcOG4MOmcMOGNQi0ghUTP" +
		"hiHvRiH7R0Uo4Zpl8uvegH1MoDa7kfzXIG3vFEy2w5LWgnDEkv7nbMeKbFyQr9NHKEZ#TOs" +
		"BgMKcJaoicSmOdrioGv3hAFEFCoEMiXFS#J8zfgrWlxnLMy$pjKOsDvimmEwvbzKEikubqA" +
		"sRFwDR7kySPvrzjU#pMzjVHPlxv#2t4#6qOVAnSZFMEy2tCioxLNpTRtkzIhhRz61l5HzSO" +
		"t2Ums$6J$UGGEKhsaeFa93bEBZaxTNBvT9CZf4JUJn3dp4xB#tboWLmcUyWLSfPS8vtaXXF" +
		"dmgTBx1lIIswI24cGfzBNGvf92tacleUaLNIRs57oN7GVsKLUadraaDj#J$kQ72134jTFtf" +
		"B3P5Xy0sAVa0xYv9qY8zQwEyGss$iP3pu1Iv#nz2sntM9lYxqZzgxO7h7tiiQzd$N#GEmvo" +
		"zShzgBbw$lFUXzP#ghO2h6TEUAlMxf9x6FBrsNfTeppg5$gfnhKwWVX#IX#7sg8yFpKAy9p" +
		"LI$Ki1Eb1Z9olu#fRxhzIhvezTcA#YJseneLzK6Dw2$4ZNZ7faRVzGRUmIHlIvmwJktyyZd" +
		"$NnAyumdUpeJsEJP0YgGlo5yr7$7pjosWRsTCt#HiNBzVsyQ$RnRIcG==");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN9 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 9];
		}
	};

	private final Action[] actions;

	public LanguageParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.RETURN,	// [0] $goal = stmts
			RETURN2,	// [1] $goal = $placeholder placeholder; returns 'placeholder' although none is marked
			RETURN9,	// [2] placeholder = COMMA LBRACKET RBRACKET LPAREN RPAREN STRING TRUE FALSE SUB; returns 'SUB' although none is marked
			new Action() {	// [3] stmts = stmt.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new StmtList(s);
				}
			},
			new Action() {	// [4] stmts = stmt.s stmts.ss
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final Stmt s = (Stmt) _symbol_s.value;
					final Symbol _symbol_ss = _symbols[offset + 2];
					final StmtList ss = (StmtList) _symbol_ss.value;
					 return new StmtList(s, ss);
				}
			},
			new Action() {	// [5] stmt = IDENTIFIER.i ASSIGN expr.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					 return new AssignStmt(i, e);
				}
			},
			new Action() {	// [6] stmt = FOR IDENTIFIER.i IN expr.e LCURLY stmts.ss RCURLY
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_ss = _symbols[offset + 6];
					final StmtList ss = (StmtList) _symbol_ss.value;
					 return new ForStmt(i, e, ss);
				}
			},
			new Action() {	// [7] stmt = WHILE expr.e LCURLY stmts.ss RCURLY
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_ss = _symbols[offset + 4];
					final StmtList ss = (StmtList) _symbol_ss.value;
					 return new WhileStmt(e, ss);
				}
			},
			new Action() {	// [8] stmt = RETURN expr.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new ReturnStmt(e);
				}
			},
			new Action() {	// [9] stmt = expr.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
				}
			},
			new Action() {	// [10] stmt = VAR IDENTIFIER.i SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					 return new DeclStmt(i, null);
				}
			},
			new Action() {	// [11] stmt = IF expr.e THEN LCURLY stmts.ss RCURLY
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_ss = _symbols[offset + 5];
					final StmtList ss = (StmtList) _symbol_ss.value;
					 return new IfStmt(e, ss, null, null);
				}
			},
			new Action() {	// [12] stmt = IF expr.e THEN LCURLY stmts.ss RCURLY ELSE LCURLY stmts.sss RCURLY
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_ss = _symbols[offset + 5];
					final StmtList ss = (StmtList) _symbol_ss.value;
					final Symbol _symbol_sss = _symbols[offset + 9];
					final StmtList sss = (StmtList) _symbol_sss.value;
					 return new IfStmt(e, ss, null, sss);
				}
			},
			new Action() {	// [13] stmt = IF expr.e THEN LCURLY stmts.ss RCURLY elseifs.es
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_ss = _symbols[offset + 5];
					final StmtList ss = (StmtList) _symbol_ss.value;
					final Symbol _symbol_es = _symbols[offset + 7];
					final ElseIfList es = (ElseIfList) _symbol_es.value;
					 return new IfStmt(e, ss, es, null);
				}
			},
			new Action() {	// [14] stmt = IF expr.e THEN LCURLY stmts.ss RCURLY elseifs.es ELSE LCURLY stmts.s2 RCURLY
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_ss = _symbols[offset + 5];
					final StmtList ss = (StmtList) _symbol_ss.value;
					final Symbol _symbol_es = _symbols[offset + 7];
					final ElseIfList es = (ElseIfList) _symbol_es.value;
					final Symbol _symbol_s2 = _symbols[offset + 10];
					final StmtList s2 = (StmtList) _symbol_s2.value;
					 return new IfStmt(e, ss, es, s2);
				}
			},
			new Action() {	// [15] elseifs = elseif.ei
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ei = _symbols[offset + 1];
					final ElseIf ei = (ElseIf) _symbol_ei.value;
					 return new ElseIfList(ei);
				}
			},
			new Action() {	// [16] elseifs = elseif.ei elseifs.eis
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ei = _symbols[offset + 1];
					final ElseIf ei = (ElseIf) _symbol_ei.value;
					final Symbol _symbol_eis = _symbols[offset + 2];
					final ElseIfList eis = (ElseIfList) _symbol_eis.value;
					 return new ElseIfList(ei, eis);
				}
			},
			new Action() {	// [17] elseif = ELSEIF expr.e THEN LCURLY stmts.s RCURLY
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final StmtList s = (StmtList) _symbol_s.value;
					 return new ElseIf(e, s);
				}
			},
			new Action() {	// [18] expr = INTEGER.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final BigInteger n = (BigInteger) _symbol_n.value;
					 return new IntLiteral(n);
				}
			},
			new Action() {	// [19] expr = expr.a PLUS expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new PlusExpr(a, b);
				}
			},
			new Action() {	// [20] expr = expr.a MULT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new MultExpr(a, b);
				}
			},
			new Action() {	// [21] expr = expr.a EQUAL expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new EqualExpr(a, b);
				}
			},
			new Action() {	// [22] expr = expr.a OR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new OrExpr(a, b);
				}
			},
			new Action() {	// [23] expr = expr.a AND expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new AndExpr(a,b);
				}
			},
			new Action() {	// [24] expr = IDENTIFIER.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					 return new IdentExpr(i);
				}
			},
			new Action() {	// [25] expr = expr.a NOTEQL expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new NotEqlExpr(a, b);
				}
			},
			new Action() {	// [26] expr = NOT expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new NotExpr(a);
				}
			},
			new Action() {	// [27] expr = expr.a DIV expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new DivExpr(a, b);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
