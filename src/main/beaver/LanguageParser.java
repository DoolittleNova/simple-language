package edu.appstate.cs.analysis.parser;

import edu.appstate.cs.analysis.ast.*;
import java.math.BigInteger;
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "lang.grammar".
 */
public class LanguageParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short IDENTIFIER = 1;
		static public final short INTEGER = 2;
		static public final short NOT = 3;
		static public final short MULT = 4;
		static public final short DIV = 5;
		static public final short PLUS = 6;
		static public final short LT = 7;
		static public final short LTEQ = 8;
		static public final short GT = 9;
		static public final short GTEQ = 10;
		static public final short EQUAL = 11;
		static public final short NOTEQL = 12;
		static public final short IF = 13;
		static public final short FOR = 14;
		static public final short WHILE = 15;
		static public final short VAR = 16;
		static public final short RETURN = 17;
		static public final short OR = 18;
		static public final short AND = 19;
		static public final short LCURLY = 20;
		static public final short RCURLY = 21;
		static public final short SEMI = 22;
		static public final short THEN = 23;
		static public final short ELSE = 24;
		static public final short ELSEIF = 25;
		static public final short COMMA = 26;
		static public final short LBRACKET = 27;
		static public final short RBRACKET = 28;
		static public final short LPAREN = 29;
		static public final short RPAREN = 30;
		static public final short STRING = 31;
		static public final short TRUE = 32;
		static public final short FALSE = 33;
		static public final short SUB = 34;
		static public final short IN = 35;
		static public final short ASSIGN = 36;
	}
	static public class AltGoals {
		static public final short placeholder = 37;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9oDL3jGKq4KFGa2Xez029yeo3y9440G$03nYn$0loYYfPtEsDgfXSxeqEYC3HPsDZRQMTX" +
		"eOMbXuuoLg0Z#5H7mWwxdxTv7NY0laCovv#pTiszttzstWASVnQX40DMeHGWHb6AjKeZ1Yr" +
		"L8nsgKgPTOWSB5BdhowB7oTA4jYQCH3OXYBuvgnqPNnpuSreuZv6utb$g73EtAX0zRN9#r4" +
		"bdQPLezhhviv3fynvBuydLFZlfBdt6Pk0FDwC1MTBgEAO1VL15Aa8QWOqnS6SSQb8kgaEUv" +
		"UwjG8ygif2w5DxnWTVMkwpOjyyIcX5PBGil46DQpwhRUDA$jp6vcOkZJyQ33EKYz3gtOW7P" +
		"iHXUsOJjsOXVsOmzwUK86q8y300xXEEC9dhbqrZkJzVInejd8OJR4NKLO3J$FepLZSHANyL" +
		"XvonL8ul3mRAUnMi4b7FLSkUMmEDbCnWLMq7ALiVhkhd9MrtAPLechhv9LMOwlYlFwHPkOo" +
		"$URnzeNk8wngcrKYFyw8Zuchk8EMvddBSThjrDv4rSNSbstQIMEicT9R1c7LVN5sfbnHcU#" +
		"Hk#WY7zh7yMC0PwE8iQWpWTu7zeH6Be4$HicV4gfAV80qKbq4tr45z5Bd2BE4IU9wyGT6Nk" +
		"5Y7BidBHZ#XJnx4lxDF6EE4EC4EU9YyG5Ofgu8RwRn6FY1J47UBm4JwJ7HsHP7kFpv0lp6$" +
		"BuYK8syeYxr3NI5sIe91vIrqgkWg5LvkgH7FVf2OckPXWaDv0VaHl9fUGcyZDoY$Z2H2l5S" +
		"tARvEg5cndEajl94#GEUzryFsF2utPkAT0x4zytBZlqLU5hmiF28yAtX6yBtnE#B$n0#8dm" +
		"K#Uy$8qcjkrtZab7ha1oiuvS8DL#s5$YqFPSfT9EI#BFSAofJ7BbZluSH$yGKlpKdFgZ9hJ" +
		"wJNmYFX8VYFS4pwSQ9yQ8DyHhuXKngZvRezJRX6VzcbS$TPmbPhIQThX#24#fxw8crJVrrU" +
		"7u0kkKHlagelo26tbJXAd3rDQT7#7j4U7T4E6t7T4vYpE8BEdBvctk8RoyqpFqznxIzy12s" +
		"7blqlwc$rACxUa=");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN9 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 9];
		}
	};

	private final Action[] actions;

	public LanguageParser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			Action.RETURN,	// [0] $goal = stmts
			RETURN2,	// [1] $goal = $placeholder placeholder; returns 'placeholder' although none is marked
			RETURN9,	// [2] placeholder = COMMA LBRACKET RBRACKET LPAREN RPAREN STRING TRUE FALSE SUB; returns 'SUB' although none is marked
			new Action() {	// [3] stmts = stmt.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final Stmt s = (Stmt) _symbol_s.value;
					 return new StmtList(s);
				}
			},
			new Action() {	// [4] stmts = stmt.s stmts.ss
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_s = _symbols[offset + 1];
					final Stmt s = (Stmt) _symbol_s.value;
					final Symbol _symbol_ss = _symbols[offset + 2];
					final StmtList ss = (StmtList) _symbol_ss.value;
					 return new StmtList(s, ss);
				}
			},
			new Action() {	// [5] stmt = IDENTIFIER.i ASSIGN expr.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					 return new AssignStmt(i, e);
				}
			},
			new Action() {	// [6] stmt = FOR IDENTIFIER.i IN expr.e LCURLY stmts.ss RCURLY
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					final Symbol _symbol_e = _symbols[offset + 4];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_ss = _symbols[offset + 6];
					final StmtList ss = (StmtList) _symbol_ss.value;
					 return new ForStmt(i, e, ss);
				}
			},
			new Action() {	// [7] stmt = WHILE expr.e LCURLY stmts.ss RCURLY
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_ss = _symbols[offset + 4];
					final StmtList ss = (StmtList) _symbol_ss.value;
					 return new WhileStmt(e, ss);
				}
			},
			new Action() {	// [8] stmt = RETURN expr.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					 return new ReturnStmt(e);
				}
			},
			new Action() {	// [9] stmt = expr.e SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 1];
					final Expr e = (Expr) _symbol_e.value;
					 return new ExprStmt(e);
				}
			},
			new Action() {	// [10] stmt = VAR IDENTIFIER.i SEMI
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 2];
					final String i = (String) _symbol_i.value;
					 return new DeclStmt(i, null);
				}
			},
			new Action() {	// [11] stmt = IF expr.e THEN LCURLY stmts.ss RCURLY
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_ss = _symbols[offset + 5];
					final StmtList ss = (StmtList) _symbol_ss.value;
					 return new IfStmt(e, ss, null, null);
				}
			},
			new Action() {	// [12] stmt = IF expr.e THEN LCURLY stmts.ss RCURLY ELSE LCURLY stmts.sss RCURLY
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_ss = _symbols[offset + 5];
					final StmtList ss = (StmtList) _symbol_ss.value;
					final Symbol _symbol_sss = _symbols[offset + 9];
					final StmtList sss = (StmtList) _symbol_sss.value;
					 return new IfStmt(e, ss, null, sss);
				}
			},
			new Action() {	// [13] stmt = IF expr.e THEN LCURLY stmts.ss RCURLY elseifs.es
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_ss = _symbols[offset + 5];
					final StmtList ss = (StmtList) _symbol_ss.value;
					final Symbol _symbol_es = _symbols[offset + 7];
					final ElseIfList es = (ElseIfList) _symbol_es.value;
					 return new IfStmt(e, ss, es, null);
				}
			},
			new Action() {	// [14] stmt = IF expr.e THEN LCURLY stmts.ss RCURLY elseifs.es ELSE LCURLY stmts.s2 RCURLY
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_ss = _symbols[offset + 5];
					final StmtList ss = (StmtList) _symbol_ss.value;
					final Symbol _symbol_es = _symbols[offset + 7];
					final ElseIfList es = (ElseIfList) _symbol_es.value;
					final Symbol _symbol_s2 = _symbols[offset + 10];
					final StmtList s2 = (StmtList) _symbol_s2.value;
					 return new IfStmt(e, ss, es, s2);
				}
			},
			new Action() {	// [15] elseifs = elseif.ei
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ei = _symbols[offset + 1];
					final ElseIf ei = (ElseIf) _symbol_ei.value;
					 return new ElseIfList(ei);
				}
			},
			new Action() {	// [16] elseifs = elseif.ei elseifs.eis
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ei = _symbols[offset + 1];
					final ElseIf ei = (ElseIf) _symbol_ei.value;
					final Symbol _symbol_eis = _symbols[offset + 2];
					final ElseIfList eis = (ElseIfList) _symbol_eis.value;
					 return new ElseIfList(ei, eis);
				}
			},
			new Action() {	// [17] elseif = ELSEIF expr.e THEN LCURLY stmts.s RCURLY
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 2];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_s = _symbols[offset + 5];
					final StmtList s = (StmtList) _symbol_s.value;
					 return new ElseIf(e, s);
				}
			},
			new Action() {	// [18] expr = INTEGER.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final BigInteger n = (BigInteger) _symbol_n.value;
					 return new IntLiteral(n);
				}
			},
			new Action() {	// [19] expr = expr.a PLUS expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new PlusExpr(a, b);
				}
			},
			new Action() {	// [20] expr = expr.a MULT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new MultExpr(a, b);
				}
			},
			new Action() {	// [21] expr = expr.a EQUAL expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new EqualExpr(a, b);
				}
			},
			new Action() {	// [22] expr = expr.a OR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new OrExpr(a, b);
				}
			},
			new Action() {	// [23] expr = expr.a AND expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new AndExpr(a,b);
				}
			},
			new Action() {	// [24] expr = IDENTIFIER.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_i = _symbols[offset + 1];
					final String i = (String) _symbol_i.value;
					 return new IdentExpr(i);
				}
			},
			new Action() {	// [25] expr = expr.a NOTEQL expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new NotEqlExpr(a, b);
				}
			},
			new Action() {	// [26] expr = NOT expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new NotExpr(a);
				}
			},
			new Action() {	// [27] expr = expr.a DIV expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new DivExpr(a, b);
				}
			},
			new Action() {	// [28] expr = expr.a LT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new LtExpr(a, b);
				}
			},
			new Action() {	// [29] expr = expr.a LTEQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new LtEqExpr(a, b);
				}
			},
			new Action() {	// [30] expr = expr.a GT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new GtExpr(a, b);
				}
			},
			new Action() {	// [31] expr = expr.a GTEQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new GtEqExpr(a, b);
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
