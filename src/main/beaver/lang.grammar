%package "edu.appstate.cs.analysis.parser";
%class "LanguageParser";
%import "edu.appstate.cs.analysis.ast.*";
%import "java.math.BigInteger";

%terminals FOR, RETURN, WHILE,
           IN, ELSEIF, ELSE, ASSIGN, SEMI,
           LCURLY, RCURLY, THEN, COMMA, LBRACKET,
           RBRACKET, LPAREN, RPAREN, INTEGER, STRING,
           TRUE, FALSE, IDENTIFIER, PLUS, MULT, NOTEQL, DIV, SUB, IF,
           VAR, NOT;

%typeof INTEGER = "BigInteger";
%typeof IDENTIFIER = "String";
%typeof stmts = "StmtList";
%typeof expr = "Expr";
%typeof stmt = "Stmt";
%typeof elseifs = "ElseIfList";
%typeof elseif = "ElseIf";

%goal stmts;

/* This can be removed once all tokens are used in a real production */
/* START */
%goal placeholder;
placeholder = RETURN WHILE IN IF ELSEIF ELSE LCURLY RCURLY THEN COMMA LBRACKET RBRACKET LPAREN RPAREN STRING TRUE FALSE VAR;
/* END */

stmts
    = stmt.s {: return new StmtList(s); :}
    | stmt.s stmts.ss {: return new StmtList(s, ss); :}
    ;

stmt
    = IDENTIFIER.i ASSIGN expr.e SEMI {: return new AssignStmt(i, e); :}
    | FOR IDENTIFIER.i IN expr.e LCURLY stmts.ss RCURLY {: return new ForStmt(i, e, ss); :}
    | IF expr.e THEN LCURLY stmts.ss RCURLY {: return new IfStmt(e, ss, null, null); :}
    | WHILE expr.e LCURLY stmts.ss RCURLY {: return new WhileStmt(e, ss); :}
    | expr.e SEMI {: return new ExprStmt(e); :}
    | VAR IDENTIFIER.i SEMI {: return new DeclStmt(i, null); :}
    | IF expr.e THEN LCURLY stmts.ss RCURLY elseifs.es ELSE LCURLY stmts.s2 RCURLY {: return new IfStmt(e, ss, es, s2); :}
    ;

elseifs
    = elseif.ei {: return new ElseIfList(ei); :}
    | elseif.ei elseifs.eis {: return new ElseIfList(ei, eis); :}
    ;

elseif
    = ELSEIF expr.e THEN LCURLY stmts.s RCURLY {: return new ElseIf(e, s); :}
    ;

expr
    = INTEGER.n {: return new IntLiteral(n); :}
    | expr.a PLUS expr.b {: return new PlusExpr(a, b); :}
    | expr.a MULT expr.b {: return new MultExpr(a, b); :}
    | expr.a DIV expr.b {: return new DivExpr(a, b); :}
    | IDENTIFIER.i {: return new IdentExpr(i); :}
    | expr.a NOTEQL expr.b {: return new NotEqlExpr(a, b); :}
    | NOT expr.a {: return new NotExpr(a); :}
    ;
